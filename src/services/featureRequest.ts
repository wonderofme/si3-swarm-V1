import nodemailer from 'nodemailer';

const FEATURE_REQUEST_EMAIL = 'tech@si3.space';
const NO_MATCH_EMAIL = 'members@si3.space';

// Helper function to format camelCase keys to readable Title Case
function formatFieldName(key: string): string {
  // Handle special cases first
  const specialCases: Record<string, string> = {
    'userId': 'User ID',
    'onboardingCompletedAt': 'Onboarding Completed At',
  };
  
  if (specialCases[key]) {
    return specialCases[key];
  }
  
  // Convert camelCase to Title Case with spaces
  // Split on capital letters and join with spaces
  const words: string[] = [];
  let currentWord = '';
  
  for (let i = 0; i < key.length; i++) {
    const char = key[i];
    if (char >= 'A' && char <= 'Z' && currentWord.length > 0) {
      // Capital letter found and we have a word, start new word
      words.push(currentWord);
      currentWord = char;
    } else {
      currentWord += char;
    }
  }
  
  if (currentWord.length > 0) {
    words.push(currentWord);
  }
  
  // Capitalize first letter of each word
  return words
    .map(word => word.charAt(0).toUpperCase() + word.slice(1).toLowerCase())
    .join(' ');
}

// Create transporter function - create it fresh each time to ensure env vars are current
function createTransporter() {
  const smtpHost = process.env.SMTP_HOST || 'smtp.gmail.com';
  const smtpPort = parseInt(process.env.SMTP_PORT || '587');
  const smtpUser = process.env.SMTP_USER;
  const smtpPass = process.env.SMTP_PASS;

  if (!smtpUser || !smtpPass) {
    throw new Error('SMTP credentials not configured');
  }

  return nodemailer.createTransport({
    host: smtpHost,
    port: smtpPort,
    secure: smtpPort === 465, // true for 465, false for other ports
    auth: {
      user: smtpUser,
      pass: smtpPass,
    },
    // Explicit TLS configuration for better compatibility with ProtonMail and other providers
    // STARTTLS is automatically used when secure: false and port is 587
    requireTLS: smtpPort === 587, // Require TLS for port 587 (STARTTLS)
  });
}

export async function sendFeatureRequest(
  userId: string,
  userName: string,
  userMessage: string,
  featureRequest: string
): Promise<void> {
  // Check if SMTP credentials are configured
  const smtpHost = process.env.SMTP_HOST || 'smtp.gmail.com';
  const smtpPort = parseInt(process.env.SMTP_PORT || '587');
  const smtpUser = process.env.SMTP_USER;
  const smtpPass = process.env.SMTP_PASS;

  if (!smtpUser || !smtpPass) {
    console.error('[Feature Request] ‚ùå SMTP credentials not configured');
    console.error('[Feature Request] SMTP_USER:', smtpUser ? 'SET' : 'MISSING');
    console.error('[Feature Request] SMTP_PASS:', smtpPass ? 'SET' : 'MISSING');
    throw new Error('SMTP credentials not configured. Please set SMTP_USER and SMTP_PASS environment variables.');
  }

  console.log('[Feature Request] üìß Attempting to send email...');
  console.log('[Feature Request] SMTP_HOST:', smtpHost);
  console.log('[Feature Request] SMTP_PORT:', smtpPort);
  console.log('[Feature Request] SMTP_USER:', smtpUser);
  console.log('[Feature Request] SMTP_PASS:', smtpPass ? '***' + smtpPass.slice(-4) : 'MISSING');

  const mailOptions = {
    from: process.env.SMTP_USER,
    to: FEATURE_REQUEST_EMAIL,
    subject: `Feature Request from ${userName || 'User'} (${userId})`,
    text: `A user has submitted a feature request through Agent Kaia.

User ID: ${userId}
User Name: ${userName || 'Not provided'}
Original Message: ${userMessage}

Feature Request:
${featureRequest}

---
This email was automatically generated by Agent Kaia.`,
    html: `
      <h2>Feature Request from Agent Kaia</h2>
      <p><strong>User ID:</strong> ${userId}</p>
      <p><strong>User Name:</strong> ${userName || 'Not provided'}</p>
      <p><strong>Original Message:</strong> ${userMessage}</p>
      <hr>
      <h3>Feature Request:</h3>
      <p>${featureRequest.replace(/\n/g, '<br>')}</p>
      <hr>
      <p><em>This email was automatically generated by Agent Kaia.</em></p>
    `,
  };

  try {
    const transporter = createTransporter();
    await transporter.sendMail(mailOptions);
    console.log(`[Feature Request] ‚úÖ Successfully sent feature request to ${FEATURE_REQUEST_EMAIL}`);
  } catch (error: any) {
    console.error('[Feature Request] ‚ùå Error sending email:', error);
    
    // Provide more helpful error messages
    if (error.code === 'EAUTH') {
      console.error('[Feature Request] Authentication failed. Common causes:');
      console.error('[Feature Request] 1. Using regular password instead of App Password (for Gmail)');
      console.error('[Feature Request] 2. Incorrect username or password');
      console.error('[Feature Request] 3. 2-Step Verification not enabled (for Gmail)');
      console.error('[Feature Request] 4. App Password not generated');
      throw new Error('SMTP authentication failed. Please check your SMTP credentials. For Gmail, make sure you\'re using an App Password, not your regular password.');
    } else if (error.code === 'ECONNECTION' || error.code === 'ETIMEDOUT') {
      throw new Error('Could not connect to SMTP server. Please check SMTP_HOST and SMTP_PORT settings.');
    } else {
      throw error;
    }
  }
}

export async function sendNoMatchNotification(
  userId: string,
  userProfile: any,
  runtime?: any
): Promise<void> {
  const smtpHost = process.env.SMTP_HOST || 'smtp.gmail.com';
  const smtpPort = parseInt(process.env.SMTP_PORT || '587');
  const smtpUser = process.env.SMTP_USER;
  const smtpPass = process.env.SMTP_PASS;

  if (!smtpUser || !smtpPass) {
    console.error('[No Match Notification] ‚ùå SMTP credentials not configured');
    throw new Error('SMTP credentials not configured');
  }

  console.log('[No Match Notification] üìß Attempting to send no-match notification...');
  
  // Track manual connection request in database
  if (runtime) {
    try {
      const db = runtime.databaseAdapter as any;
      const databaseType = (process.env.DATABASE_TYPE || 'postgres').toLowerCase();
      const isMongo = databaseType === 'mongodb' || databaseType === 'mongo';
      
      if (isMongo && db && db.getDb) {
        const mongoDb = await db.getDb();
        const manualRequestsCollection = mongoDb.collection('manual_connection_requests');
        await manualRequestsCollection.insertOne({
          userId: userId,
          userName: userProfile.name || 'Unknown',
          telegramHandle: userProfile.telegramHandle || null,
          created_at: new Date(),
          status: 'pending'
        });
        console.log('[No Match Notification] ‚úÖ Tracked manual connection request in MongoDB');
      } else if (db && db.query) {
        // PostgreSQL
        const { v4: uuidv4 } = await import('uuid');
        await db.query(
          `INSERT INTO manual_connection_requests (id, user_id, user_name, telegram_handle, created_at, status) 
           VALUES ($1, $2::text, $3, $4, NOW(), 'pending')`,
          [uuidv4(), userId, userProfile.name || 'Unknown', userProfile.telegramHandle || null]
        );
        console.log('[No Match Notification] ‚úÖ Tracked manual connection request in PostgreSQL');
      }
    } catch (trackErr: any) {
      console.error('[No Match Notification] ‚ö†Ô∏è Could not track in database:', trackErr.message);
      // Don't fail the email send if tracking fails
    }
  }

  // Build user info (excluding anonymous fields like gender and diversity research)
  const userInfo = {
    userId: userId,
    name: userProfile.name || 'Not provided',
    location: userProfile.location || 'Not provided',
    language: userProfile.language || 'en',
    roles: userProfile.roles?.join(', ') || 'Not provided',
    interests: userProfile.interests?.join(', ') || 'Not provided',
    connectionGoals: userProfile.connectionGoals?.join(', ') || 'Not provided',
    events: userProfile.events?.join(', ') || 'None',
    socials: userProfile.socials?.join(', ') || 'None',
    telegramHandle: userProfile.telegramHandle ? `@${userProfile.telegramHandle}` : 'Not provided',
    notifications: userProfile.notifications || 'Not provided',
    onboardingCompletedAt: userProfile.onboardingCompletedAt ? new Date(userProfile.onboardingCompletedAt).toISOString() : 'Not provided'
  };

  const mailOptions = {
    from: smtpUser,
    to: NO_MATCH_EMAIL,
    subject: `No Match Found - User Needs Manual Connection: ${userInfo.name} (${userId})`,
    text: `A user requested a match but no matches were found in the current pool.

User Information:
${Object.entries(userInfo).map(([key, value]) => `${formatFieldName(key)}: ${value}`).join('\n')}

Action Required:
Please review this user's profile and explore potential matches within the broader SI<3> network.

---
This email was automatically generated by Agent Kaia when no matches were found.`,
    html: `
      <h2>No Match Found - User Needs Manual Connection</h2>
      <p>A user requested a match but no matches were found in the current pool.</p>
      
      <h3>User Information:</h3>
      <table style="border-collapse: collapse; width: 100%;">
        ${Object.entries(userInfo).map(([key, value]) => `
          <tr>
            <td style="padding: 8px; border: 1px solid #ddd; font-weight: bold;">${formatFieldName(key)}:</td>
            <td style="padding: 8px; border: 1px solid #ddd;">${value}</td>
          </tr>
        `).join('')}
      </table>
      
      <hr>
      <p><strong>Action Required:</strong> Please review this user's profile and explore potential matches within the broader SI<3> network.</p>
      
      <hr>
      <p><em>This email was automatically generated by Agent Kaia when no matches were found.</em></p>
    `,
  };

  try {
    const transporter = createTransporter();
    await transporter.sendMail(mailOptions);
    console.log(`[No Match Notification] ‚úÖ Successfully sent no-match notification to ${NO_MATCH_EMAIL}`);
  } catch (error: any) {
    console.error('[No Match Notification] ‚ùå Error sending email:', error);
    // Don't throw - this is a notification, not critical
  }
}

